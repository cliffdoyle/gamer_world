package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"github.com/google/uuid"
)

// UserDetails mirrors the structure we expect from the User Service.
// It's important that the JSON tags match what the User Service returns.
// Your tournament-service UserResponse has `id` (int) and `username` (string).
// We need to map this to our needs, especially UserID as UUID.
type UserDetails struct {
	ID       uuid.UUID `json:"-"` // We'll derive this if User Service returns numeric ID
	NumericID int      `json:"id"` // Assuming User Service returns this
	Username string    `json:"username"`
	// Add other relevant fields if User Service provides them
}

// UserServiceClient defines the interface for interacting with an external User Service.
type UserServiceClient interface {
	GetUserDetails(ctx context.Context, userID uuid.UUID) (*UserDetails, error)
	GetMultipleUserDetails(ctx context.Context, userIDs []uuid.UUID) (map[uuid.UUID]UserDetails, error)
}

// httpUserServiceClient implements UserServiceClient using HTTP.
type httpUserServiceClient struct {
	baseURL string
	client  *http.Client
	// interServiceKey string // For secure communication between services
}

// NewHTTPUserServiceClient creates a new HTTP client for the User Service.
func NewHTTPUserServiceClient(baseURL string /*, interServiceKey string */) UserServiceClient {
	if baseURL == "" {
		log.Println("Warning: USER_SERVICE_URL is not set for HTTPUserServiceClient. Client will not function.")
	}
	return &httpUserServiceClient{
		baseURL: baseURL,
		client: &http.Client{
			Timeout: 10 * time.Second, // Sensible default timeout
		},
		// interServiceKey: interServiceKey,
	}
}

// GetUserUUID converts a numeric user ID to a UUID using the same deterministic method
// as in your tournament-service.
func deriveUserUUID(numericID int) uuid.UUID {
	idStr := fmt.Sprintf("user-%d", numericID)
	return uuid.NewSHA1(uuid.NameSpaceDNS, []byte(idStr))
}

// GetNumericIDFromUUID attempts to reverse the UUID derivation.
// This is a bit hacky and depends on the exact format "user-%d".
// It's generally better if the User Service can be queried by UUID directly.
// func getNumericIDFromUUID(userID uuid.UUID) (string, bool) {
	// This is a simplified example. In a real scenario, you might have a lookup
	// or the User Service might accept UUIDs.
	// If your User Service *only* accepts numeric IDs, this is tricky.
	// Let's assume for now the User Service has an endpoint that takes a numeric ID.
	// How do we get this numeric ID from the UUIDs stored in ranking-service?
	//
	// OPTION 1: User Service exposes an endpoint /users/by-uuid/{uuid} (Ideal)
	// OPTION 2: We store NumericID alongside UUID in ranking-service (adds redundancy)
	// OPTION 3: We try to "parse" it back. This is fragile.
	//
	// For this example, let's assume we can't query User Service by UUID directly
	// and we need to parse it back. This is NOT recommended for production.
	// A better approach is to have the user service provide an endpoint that accepts UUID.
	// Or, ensure the UUID generated by tournament-service is the canonical ID stored everywhere.

	// If your user service endpoint for GetUserDetails (below) takes a numeric ID,
	// you would need to have this numeric ID available.
	// For now, let's assume the GetMultipleUserDetails can take a list of *derived* numeric IDs if needed,
	// or ideally, the user service has an endpoint for batch fetching by UUIDs.

	// Since your existing tournament-service GetUserByID takes a string (which is numeric),
	// this parsing attempt is shown for illustration if you *had* to go from UUID to numeric string.
	// s := userID.String()
	// A more robust check would be needed if other UUID generation methods are used.
	// This is highly specific to your uuid.NewSHA1(uuid.NameSpaceDNS, []byte(fmt.Sprintf("user-%d", u.ID)))
	// This reversal is generally not feasible or reliable for arbitrary SHA1 UUIDs.
	// For now, we'll assume the user service will have an endpoint for batch fetching by UUIDs or we pass numeric IDs.
	// Let's proceed assuming User Service has a /users/batch endpoint that takes UUIDs.

	// The provided tournament-service `GetUserByID` takes `userID string` which is numeric.
	// If the UUIDs in ranking service are the deterministic ones, we can't easily reverse them to get the *exact* int without knowing the int.
	// This implies the User Service should ideally accept UUIDs or have a way to look up by them.

	// Let's stick to the interface and assume GetMultipleUserDetails will be implemented
	// in a way that the User Service can handle. If User Service *only* accepts numeric IDs,
	// you have a design challenge.

	// Placeholder for now, as direct reversal of SHA1 is not practical.
	// We'll rely on User Service having a suitable batch endpoint.
	// return "", false
// }


// GetUserDetails fetches details for a single user.
// NOTE: Your current tournament-service GetUserByID takes a numeric string.
// If User Service only supports numeric IDs, you have a problem because ranking service stores UUIDs.
// Ideally, User Service should have an endpoint like /users/profile/{uuid} or /users/{uuid}
func (s *httpUserServiceClient) GetUserDetails(ctx context.Context, userID uuid.UUID) (*UserDetails, error) {
	if s.baseURL == "" {
		return nil, fmt.Errorf("user service URL is not configured")
	}

	// Assuming User Service has an endpoint that accepts UUIDs
	// If not, this needs to be adapted based on User Service capabilities.
	// Example: /api/v1/users/{uuid_as_string}
	// For this example, let's assume the endpoint is /users/profile and it can somehow identify by UUID if passed
	// or that the token validation implicitly does this. This part is a bit unclear from your provided code.
	// Let's assume an endpoint like /users/by-uuid/{userID_string} for clarity.

	url := fmt.Sprintf("%s/users/by-uuid/%s", s.baseURL, userID.String()) // ASSUMED ENDPOINT

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request to user service: %w", err)
	}
	// req.Header.Set("X-Internal-Service-Key", s.interServiceKey) // If using inter-service auth

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to call user service for user %s: %w", userID, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("user %s not found in user service (status %d)", userID, resp.StatusCode)
	}
	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("user service returned error for user %s: status %d, body: %s", userID, resp.StatusCode, string(bodyBytes))
	}

	var userSvcResponse struct { // Temporary struct to match assumed User Service JSON output
		ID       int    `json:"id"` // Numeric ID from User Service
		Username string `json:"username"`
		// Potentially other fields like email, etc.
	}
	if err := json.NewDecoder(resp.Body).Decode(&userSvcResponse); err != nil {
		return nil, fmt.Errorf("failed to decode user service response for user %s: %w", userID, err)
	}

	return &UserDetails{
		ID:        deriveUserUUID(userSvcResponse.ID), // Derive UUID to ensure consistency if needed, or use the passed `userID`
		NumericID: userSvcResponse.ID,
		Username:  userSvcResponse.Username,
	}, nil
}

// GetMultipleUserDetails fetches details for multiple users.
// This often involves a POST request with a list of IDs in the body.
func (s *httpUserServiceClient) GetMultipleUserDetails(ctx context.Context, userIDs []uuid.UUID) (map[uuid.UUID]UserDetails, error) {
	if s.baseURL == "" {
		return nil, fmt.Errorf("user service URL is not configured")
	}
	if len(userIDs) == 0 {
		return make(map[uuid.UUID]UserDetails), nil
	}

	// Assuming User Service has a batch endpoint like POST /users/batch
	// that accepts a list of UUIDs (as strings) in the request body.
	// { "user_ids": ["uuid1", "uuid2", ...] }
	// And returns a list of user objects:
	// [{ "id": 1, "username": "user1", "uuid": "uuid1_from_user_service_if_it_stores_it" }, ...]

	userIDStrings := make([]string, len(userIDs))
	for i, id := range userIDs {
		userIDStrings[i] = id.String()
	}

	requestBody, err := json.Marshal(map[string][]string{"user_ids": userIDStrings})
	if err != nil {
		return nil, fmt.Errorf("failed to marshal user IDs for batch request: %w", err)
	}

	url := fmt.Sprintf("%s/users/batch", s.baseURL) // ASSUMED BATCH ENDPOINT
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(requestBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create batch request to user service: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	// req.Header.Set("X-Internal-Service-Key", s.interServiceKey) // If using inter-service auth

	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to call user service for batch user details: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("user service returned error for batch request: status %d, body: %s", resp.StatusCode, string(bodyBytes))
	}

	var usersSvcResponse []struct { // Temporary struct to match assumed User Service JSON output for batch
		ID       int    `json:"id"` // Numeric ID from User Service
		Username string `json:"username"`
		// User Service might also return the UUID string it knows for this user:
		// UUIDStr  string `json:"uuid"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&usersSvcResponse); err != nil {
		return nil, fmt.Errorf("failed to decode batch user service response: %w", err)
	}

	results := make(map[uuid.UUID]UserDetails, len(usersSvcResponse))
	for _, u := range usersSvcResponse {
		derivedUUID := deriveUserUUID(u.ID) // Derive UUID from numeric ID
		// If User Service returned its own UUID string, parse and use that for mapping.
		// For example:
		// var keyUUID uuid.UUID
		// if u.UUIDStr != "" {
		//   keyUUID, err = uuid.Parse(u.UUIDStr)
		//   if err != nil {
		//     log.Printf("Warning: Could not parse UUID string '%s' from user service for numeric ID %d", u.UUIDStr, u.ID)
		//     keyUUID = derivedUUID // Fallback to derived
		//   }
		// } else {
		//   keyUUID = derivedUUID
		// }

		results[derivedUUID] = UserDetails{
			ID:        derivedUUID,
			NumericID: u.ID,
			Username:  u.Username,
		}
	}
	return results, nil
}