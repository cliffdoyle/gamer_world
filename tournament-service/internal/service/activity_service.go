// file: internal/service/activity_service.go
package service

import (
	"context"
	"fmt"
	"time" // For CreatedAt

	"github.com/cliffdoyle/tournament-service/internal/domain"
	"github.com/cliffdoyle/tournament-service/internal/repository"
	"github.com/google/uuid"
	"log" // For logging
)

type UserActivityService interface {
	RecordActivity(ctx context.Context, userID uuid.UUID, activityType domain.ActivityType, description string, relatedEntityID *uuid.UUID, relatedEntityType *domain.RelatedEntityType, contextURL *string) (*domain.UserActivity, error)
	GetUserActivities(ctx context.Context, userID uuid.UUID, page, pageSize int) ([]*domain.UserActivity, int, error)
}

type userActivityService struct {
	activityRepo repository.UserActivityRepository
	// Potentially other repos if needed to enrich activity data, e.g., tournamentRepo to get tournament name
	tournamentRepo repository.TournamentRepository // Example
	broadcastChan  chan<- domain.WebSocketMessage // Add this
}

func NewUserActivityService(activityRepo repository.UserActivityRepository, tournamentRepo repository.TournamentRepository,broadcastChan chan<-domain.WebSocketMessage) UserActivityService {
	return &userActivityService{
		activityRepo:   activityRepo,
		tournamentRepo: tournamentRepo, // Buffered channel for broadcasting
		broadcastChan: broadcastChan, // Injected broadcast channel
	}
}

func (s *userActivityService) RecordActivity(
	ctx context.Context,
	userID uuid.UUID,
	activityType domain.ActivityType,
	description string,
	relatedEntityID *uuid.UUID,
	relatedEntityType *domain.RelatedEntityType,
	contextURL *string,
) (*domain.UserActivity, error) {
	
	if description == "" { // Autofill description if possible based on type and related entity
		if relatedEntityID != nil && relatedEntityType != nil {
			switch *relatedEntityType {
			case domain.EntityTypeTournament:
				// Example: Fetch tournament name to make description richer
				// This requires tournamentRepo to be available in userActivityService
				if s.tournamentRepo != nil { // Check if repo is injected
					tournament, err := s.tournamentRepo.GetByID(ctx, *relatedEntityID)
					if err == nil && tournament != nil { // No error and tournament found
						switch activityType {
						case domain.ActivityTournamentJoined:
							description = fmt.Sprintf("Joined %s tournament", tournament.Name)
						case domain.ActivityTournamentCreated:
							description = fmt.Sprintf("Created %s tournament", tournament.Name)
						}
					} else {
						// Log warning: could not fetch tournament details for description
						// description will remain as passed or default for the type
						if description == "" { description = fmt.Sprintf("%s an item", activityType) }
					}
				} else {
					if description == "" { description = fmt.Sprintf("%s for entity %s", activityType, relatedEntityID.String())}
				}
			// Add cases for EntityTypeMatch etc.
			default:
				if description == "" { description = fmt.Sprintf("%s an entity", activityType) }
			}
		} else {
            if description == "" { description = fmt.Sprintf("Performed action: %s", activityType)}
        }
	}


	activity := &domain.UserActivity{
		// ID will be generated by repo or DB
		UserID:              userID,
		ActivityType:        activityType,
		Description:         description,
		RelatedEntityID:     relatedEntityID,
		RelatedEntityType:   relatedEntityType,
		ContextURL:          contextURL,
		CreatedAt:           time.Now(), // Set creation time in service
	}

	err := s.activityRepo.Create(ctx, activity)
	if err != nil {
		return nil, fmt.Errorf("failed to record activity: %w", err)
	}

	
	if s.broadcastChan != nil {
		wsPayload := domain.NewUserActivityPayload{
			Activity:  *activity,
			ForUserID: activity.UserID, // So frontend can filter if activity is for current user
		}
		wsMessage := domain.WebSocketMessage{
			Type:    domain.WSEventNewUserActivity,
			Payload: wsPayload,
		}
        // The hub will Marshal, send the struct directly
		s.broadcastChan <- wsMessage
        log.Printf("Broadcasted WSEventNewUserActivity for U-%s (Activity: %s)", activity.UserID, activity.ID)
	} else {
        log.Println("Warning: userActivityService.broadcastChan is nil. Cannot broadcast new activity.")
	}
	return activity, nil
}

func (s *userActivityService) GetUserActivities(ctx context.Context, userID uuid.UUID, page, pageSize int) ([]*domain.UserActivity, int, error) {
	if page < 1 { page = 1 }
	if pageSize < 1 { pageSize = 10 }
    if pageSize > 50 { pageSize = 50 } // Max activities per page for dashboard
	offset := (page - 1) * pageSize

	activities, total, err := s.activityRepo.GetByUserID(ctx, userID, pageSize, offset)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to get user activities: %w", err)
	}
	
	// The repository now directly returns domain.UserActivity which has 'date' as json tag for CreatedAt
	return activities, total, nil
}